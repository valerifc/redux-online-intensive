=== Docs

https://lab.lectrum.io/docs/redux/



=== Эффекты Redux Saga

import { takeEvery, all, call, apply, put } from "redux-saga/effects";

takeEvery - "на каждый запуск экшна вызывай такую-то worker-saga".
all - эффект, принимающий массив, где каждый элемент - это вызов другой watcher-saga.
call - предназначен для вызова функций, похож на метод call обычного JS. С эффектами проще поддерживать код в Redux Saga и особенно проще тестировать.
apply - аналогичен call, т.е. вызывает указанную функцию, но лучше подходит для вызова асинхронных функций. apply помогает Redux Saga сохранить контекст вызова функции при обработке асинхронной операции. Первым аргументом передается контекст вызова. Второй аргумент - метод, который необходимо вызвать. Третий аргумент - массив параметров вызываемого метода. Например: const result = yield apply(response, response.json); Здесь Redux Saga будет знать, что метод .json нужно вызывать именно в контексте объекта response.
put - работает точно так же, как store.dispatch(); то есть put предназначен для запуска экшна из worker saga.
При использовании любого эффекта redux-saga нужно обязательно использовать ключевое слово yield.


=== Домены

redux-online-intensive\source\bus\__DOMAIN__
Домен __DOMAIN__ - это домен-шаблон, который будем брать за основу при создании новых доменов.

redux-online-intensive\source\bus\ui
Домен ui хранит состояние ui приложения и некоторые метасостояния.
Состояние загрузки (активного спиннера), например, хорошо хранить в этом домене.



=== JWT токен

JSON Web Token - как пропускной билет.
При первом раз при входе в систему вводим почту и пароль.
В ответ сервер присылает личный токен.
В следующий раз отправляем свой токен и таким образом сервер нас узнает.



=== LocalStorage

В локалсторейдже есть запись loglevel:webpack-dev-server: "INFO"
Ее делает сборщи, на котором работает приложение.



=== react-router-redux
6. Продвинутая аутентификация и роутинг\7. Практика. 6 часть.mp4
Привязка React Router к Redux.
С ее помощью можно хранить и управлять состоянием роутинга в состоянии Redux.
Для хранения состоянием есть специальный редьюсер.
А для управления состоянием навигации можно запускать специальные экшны, которые предоставляет библиотеку.

import { replace } from "react-router-redux"; - экшн заменит текущий адрес в браузере указанным без возможности сделать шаг назад

Технически без этой привязки можно легко обойтись.
Но она может выручить в некоторых тонких сценариях, когда нужно явно сменить роут в какой-то глубокой операции приложения.
Аргументы в пользу этой привязки:
1) Приложение с ней становится более Redux ориентированным. Централизованное состояние Redux это удобно и гибко. Интегрировать состояние в редакс лишним не будет.
2) В некоторых случаях полезно обладать максимальной прозрачностью действий приложения. А запуск экшна Redux роутера для смены состояния навигации как раз дает такую прозрачность.
Плюсы от этоц привязки больше стилистические, чем практические.



=== immutable
Map - см. source\bus\profile\reducer.js
fromJS, List, updateIn, unshift - см. source\bus\posts\reducer.js
removeAll, remove - см. source\bus\posts\saga\workers\likePost.js
Методы remove и delete работают одинаково.



=== Web Socket
Продвинутая технология для построения коммуникации между клиентом и сервером.
Инициализация и подключение:
    source\init\socket.js
    source\navigation\App.js
Значок Оффлайн: будем менять его с помощью веб сокета, а хранить состояние - в Redux.
Интервал через который веб сокет опрашивает сеть на наличие/отсутствие интернета можно менять.
Если сделать интервал меньше, то веб сокет будет работать интенсивнее и будет больше нагружить процессор.
От этого приложение будет работать медленнее.



=== Annotation
https://eslint.org/docs/rules/valid-jsdoc (enforce valid JSDoc comments (valid-jsdoc))
https://gist.github.com/SerafimArts/f802c544d8e9d15f5eece1dfb2664929 (JavaScript Annotations example)



=== React Redux Form
Библиотека для работами с формами, как и Formik.
Только Formik хранит состояние форм в локальном состоянии компонента.
React Redux Form хранит состояние форм в глобальном состояниии Redux.
То есть предоставляет совсем другой подход управления состоянием форм.

import { Form, Control } from 'react-redux-form';

Form - это главный компонент, выполняющий роль обертки для остальных компонентов формы.
Control - это элемент формы, может представлять из себя текстовый инпут, textarea, checkbox и т.д.

<Form model = 'forms.user.profile' ... />
model - ключевой пропс компонента Redux формы - содержит адрес на модель нужной формы в состоянии Redux.
А также контролы содержат такой пропс.
По этому адресу хранится изначальное состояние и текущее состояние компонентов.

Библиотека полностью автоматизирует все взаимодействие с состоянием Redux.
Для нее не нужно никаких привязок, но нужно наличие специального редьюсера.
С помощью этого редьюсера компоненты Redux формы будут искать свои изначальные состояния:
    source\bus\forms\reducer.js

Формы Formik хранят состояние локально прямо в компоненте.
Такой подход хорош, когда форма не зависит ни от каких внешних глобальных данных.
Например, состояние формы логина хранить в Redux нет смысла:
все значения форма получает от пользователя и отправляет их серверу.

Некоторые формы нужно хранить именно в редакс. Например, форму профиля пользователя.
Ведь значения для формы профиля нужно взять из профиля, который нам присылает сервер.
А данные для профиля мы храним в Redux.
Без Redux Form'ы нужно было бы вручную привязывать к форме данные из профиля,
что очень неудобно. А менять профиль (например, имя пользователя) без Redux было бы еще более неудобно.
Redux Form нужно использовать в случае, когда форма зависит от внешних глобальных данных.



=== ISSUEs
Error: listen EADDRINUSE: address already in use 0.0.0.0:3000
CMD > as admin >
    netstat -ano | findstr :3000
    taskkill /PID type_your_PID_here /F



=== GIT
Создаем новую ветку из текущей и чекаутимся в нее: 
git checkout -b hw-08 



=== JEST
Ищет файлы с ".test.js" на конце и те, что находятся в папке "__tests__".

yarn test:watch - watch режим Jest, чтобы не запускать тесты каждый раз командой yarn test.

Jest запускает каждый раз перед запуском каждого нового теста файл jest\scripts\setupFiles.js
Это предварительный скрипт Jest. В нем можно описывать любые предварительные операции для тестов.
В конце setupFiles.js все необходимые сущности привязываем к свойству __ глобального объекта nodeJS global (global.__).
Это будет нашим служебным свойством, из которого будем доставать нужные тестовые данные.

Jest не соблюдает порядок снапшотов внутри файлов .snap
source\bus\profile\__tests__\__snapshots__\actions.js.snap



=== Test Saga
https://github.com/jfairbank/redux-saga-test-plan
Библиотека для решения трудностей тестирования Redux Saga саг с развервленным кодом.
Больше не нужно тестировать каждый yield функции генератора с учетом его расположения.
С этой библиотекой проверяется лишь факт вызова того или иного эффекта.
Обо всем остальном redux-saga-test-plan позаботатся сам.
Порядок тестов никак не привязан к порядку ключевых слов yield внутри функции генератора.

Example: source\bus\auth\__tests__\authenticate.saga.js

→ expectSaga
import { expectSaga } from "redux-saga-test-plan";
expectSaga запустит сагу в паре с настоящим Saga middleware и попытается
вычислить каждый эффект так, как это сделал бы Saga middleware в условиях реальной работе.
expectSaga возвращает промис, поэтому тесты асинхронные.

→ provide 
Принимает массив со вложенными двухэлементными массивами.
Первый элемент вложенного массива - описание эффекта, для которого мы эмулируем ответ сервера.
Второй элемент вложенного массива - эмулированные данные.
В результате сага генератор выполнит тот сценарий, который нам сейчас нужен:
после вызова provide redux-saga-test-plan найдет внутри саги вызов эффекта, который мы эмулируем и
пробросит внутрь генератора эмулированные данные. В результате эмулированные данные в тесте окажутся
привязанными в идентификатору response команды const response = yield apply(api, api.auth.authenticate);
